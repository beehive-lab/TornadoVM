#!/usr/bin/env python3

#
# Copyright (c) 2013-2025, APT Group, Department of Computer Science,
# The University of Manchester.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import argparse
import os
import shutil
import subprocess
import sys

import install_python_modules as tornadoReq
tornadoReq.check_python_dependencies()

import config_utils as cutils

import update_paths as updp
import pull_graal_jars


__LEVEL_ZERO_JNI_VERSION__ = "0.1.5"
__BEEHIVE_SPIRV_TOOLKIT_VERSION__ = "0.0.5"



def get_mvn_command():
    """
    Returns the appropriate Maven command (mvnw or mvnw.cmd) based on the operating system.

    Returns:
        str: The Maven wrapper command to use.
    """
    if os.name == 'nt':
        return ".\\mvnw.cmd"
    else:
        return "./mvnw"


def is_win_or_bat():
    """
    Returns boolean indicating whether the operating system is Windows or not.

    Returns:
        bool: True if the operating system is Windows, False otherwise.
    """
    if os.name == 'nt':
        isWinCmdOrBat = True
    else:
        isWinCmdOrBat = False
    return isWinCmdOrBat


def check_java_version():
    """
    Check if JAVA_HOME env variable is loaded. It exits the compilation if it is not
    declared.
    """
    print("Checking JAVA_HOME env variable ................ ",  end='')
    try:
        os.environ['JAVA_HOME']
        print("[OK]")
    except:
        print("[ERROR] \n\t JAVA_HOME env variable not defined\n\n \t Suggestion (Linux and OSx): export JAVA_HOME=<path-to-jdk21>\n"),
        sys.exit(-1)

    """
    Checks the Java version in the system.

    Returns:
        str: The Java version information.
    """
    java_home = os.environ.get("JAVA_HOME")
    if java_home == None:
        print("JAVA_HOME not found.")
        sys.exit(-1)
    java_cmd = os.path.join(java_home, "bin", "java")
    java_version_output = subprocess.check_output(
        [java_cmd, "-version"], stderr=subprocess.STDOUT, universal_newlines=True
    )

    return java_version_output


def pull_graal_jars_if_needed(graal_jars_status):
    """
    Pulls GraalVM jars if the specified JDK version does not contain the binaries.

    Args:
        jdk (str): The JDK version.
    """
    if graal_jars_status:
        pull_graal_jars.main()


def should_handle_graal_jars(jdk):
    java_version_output = check_java_version()
    return jdk == "jdk21" and "GraalVM" not in java_version_output


def maven_cleanup():
    mvn_cmd = get_mvn_command()
    print("mvnw -Popencl-backend,ptx-backend,spirv-backend clean")

    subprocess.run(
        [mvn_cmd, "-Popencl-backend,ptx-backend,spirv-backend", "clean"],
        stdout=subprocess.PIPE, shell=is_win_or_bat()
    )


def process_backends_as_mvn_profiles(selected_backends):
    """
    Processes the list of selected backend options and converts them to the required format required for the maven profile.

    Args:
        selected_backends (str): Comma-separated list of selected backend options.

    Returns:
        str: The processed backend options.
    """
    selected_backends_list = selected_backends.split(",")
    for i, backend in enumerate(selected_backends_list):
        selected_backends_list[i] = f"{backend}-backend"
    backend_profiles = ",".join(selected_backends_list)

    return backend_profiles


def clone_opencl_headers():
    """
    Clone the Khronos OpenCL headers into the OpenCL JNI lib
    """
    current = os.getcwd()
    directoryName = os.path.join("tornado-drivers", "opencl-jni", "src", "main", "cpp", "headers")
    if not os.path.exists(directoryName):
        ## clone the repo with the OpenCL Headers
        subprocess.run(
            [
                "git",
                "clone",
                "https://github.com/KhronosGroup/OpenCL-Headers.git",
            ],
        )
        os.chdir("OpenCL-Headers")
        subprocess.run(
            [
                "cmake",
                "-S",
                ".",
                "-B",
                "build",
                "-DCMAKE_INSTALL_PREFIX=" + os.path.join(current, directoryName),
            ],
        )
        subprocess.run(
            [
                "cmake",
                "--build",
                "build",
                "--target",
                "install",
            ],
        )
        os.chdir(current)


def build_levelzero_jni_lib(rebuild=False):
    """
    Pulls and Builds the Level Zero JNI library
    """
    current = os.getcwd()
    levelzero_jni = "levelzero-jni"
    build=False
    if not os.path.exists(levelzero_jni):
        ## clone only if directory does not exist
        subprocess.run(
            [
                "git",
                "clone",
                "https://github.com/beehive-lab/levelzero-jni.git",
            ],
        )
        build=True

    if (rebuild or build):

        os.chdir(levelzero_jni)

        ## Switch branch to the tagged version
        subprocess.run(
            [
                "git",
                "switch",
                "-c",
                __LEVEL_ZERO_JNI_VERSION__
            ],
        )

        mvn_cmd = get_mvn_command()
        ## Always pull for the latest changes
        subprocess.run(["git", "pull", "origin", __LEVEL_ZERO_JNI_VERSION__])
        subprocess.run([mvn_cmd, "clean", "install"], shell=is_win_or_bat())

        ## Build native library
        os.chdir("levelZeroLib")
        levelzero_build_directory_cpp = "build"
        if not os.path.exists(levelzero_build_directory_cpp):
            os.mkdir(levelzero_build_directory_cpp)
        os.chdir(levelzero_build_directory_cpp)

        subprocess.run(["cmake", "..", ],)
        subprocess.run(["cmake", "--build", ".", "--config", "Release"],)

        os.chdir(current)


def build_spirv_toolkit_and_level_zero(rebuild=False):
    """
    Builds the SPIR-V Toolkit and Level Zero libraries.
    """
    current = os.getcwd()
    spirv_tool_kit = "beehive-spirv-toolkit"
    build=True
    if not os.path.exists(spirv_tool_kit):
        subprocess.run(
            [
                "git",
                "clone",
                "https://github.com/beehive-lab//beehive-spirv-toolkit.git",
            ],
        )
        build = True

    if (rebuild or build):
        os.chdir(spirv_tool_kit)

        ## Switch branch to the tagged version
        subprocess.run(
            [
                "git",
                "switch",
                "-c",
                __BEEHIVE_SPIRV_TOOLKIT_VERSION__
            ],
        )

        mvn_cmd = get_mvn_command()
        subprocess.run(["git", "pull", "origin", "master"])

        subprocess.run([mvn_cmd, "clean", "package"], shell=is_win_or_bat())
        subprocess.run([mvn_cmd, "install"], shell=is_win_or_bat())
        os.chdir(current)

        level_zero_lib = "level-zero"

        if not os.path.exists(level_zero_lib):
            subprocess.run(["git", "clone", "--branch", "v1.17.45", "https://github.com/oneapi-src/level-zero"])
            os.chdir(level_zero_lib)
            os.mkdir("build")
            os.chdir("build")
            subprocess.run(["cmake", ".."])
            subprocess.run(["cmake", "--build", ".", "--config", "Release"])
            os.chdir(current)

    if os.name == 'nt':
        subprocess.run([os.path.join(level_zero_lib, "build", "bin", "Release", "zello_world")])
        zeSharedLoader = os.path.join("level-zero", "build", "lib", "Release", "ze_loader.lib")
    else:
        subprocess.run([os.path.join(level_zero_lib, "build", "bin", "zello_world")])
        zeSharedLoader = os.path.join("level-zero", "build", "lib", "libze_loader.so")


    os.environ["ZE_SHARED_LOADER"] = os.path.join(
        current, zeSharedLoader
    )
    os.environ["CPLUS_INCLUDE_PATH"] = (
        os.path.join(current, "level-zero", "include")
        + os.pathsep
        + os.environ.get("CPLUS_INCLUDE_PATH", "")
    )
    os.environ["C_INCLUDE_PATH"] = (
        os.path.join(current, "level-zero", "include")
        + os.pathsep
        + os.environ.get("C_INCLUDE_PATH", "")
    )
    if os.name == 'nt':
        os.environ["PATH"] = (
            os.path.join(current, "level-zero", "build", "bin", "Release")
            + os.pathsep
            + os.environ.get("PATH", "")
        )
    else:
        os.environ["LD_LIBRARY_PATH"] = (
            os.path.join(current, "level-zero", "build", "lib")
            + os.pathsep
            + os.environ.get("LD_LIBRARY_PATH", "")
        )

    return current


def build_tornadovm(args, backend_profiles):
    """
    Builds TornadoVM with the specified JDK and backend options.

    Args:
        args (object): The arguments passed by the user. The JDK version as well as other options (e.g., if polyglot is used).
        backend_profiles (str): The processed backend options.

    Returns:
        CompletedProcess: Result of the Maven build process.
    """
    try:
        mvn_cmd = get_mvn_command()

        # Create tornado.backend file in source before Maven assembly (for Windows compatibility)
        # Maven filtering doesn't work reliably on Windows, so we pre-create the file
        backend_template_path = os.path.join("tornado-assembly", "src", "etc", "tornado.backend")
        with open(backend_template_path, "w") as backend_file:
            backend_file.write(f"tornado.backends={backend_profiles}\n")

        process = [mvn_cmd]
        # Only override threading if single-threaded mode explicitly requested
        # Default parallel build (-T1.5C) is configured in .mvn/maven.config
        if args.mavenSingleThreaded:
            process.append("-T1")

        if args.polyglot:
            process.append(f"-P{args.jdk},{backend_profiles},graalvm-polyglot")
        else:
            process.append(f"-P{args.jdk},{backend_profiles}")

        # Determine backend variant for SDKMAN-compliant archive naming
        backend_list = args.backend.split(",")
        backend_list_sorted = sorted(backend_list)

        # If all three backends, use "full"
        if set(backend_list_sorted) == {"opencl", "ptx", "spirv"}:
            backend_variant = "full"
        else:
            # Single backend or partial combination - use exact name(s)
            backend_variant = "-".join(backend_list_sorted)

        # Pass properties to Maven
        # tornado.backend: for archive naming (e.g., "opencl", "full")
        # Note: tornado.backend.profiles not needed anymore since we pre-create the file
        process.append(f"-Dtornado.backend={backend_variant}")

        process.append("install")
        print(' '.join(process))

        result = subprocess.run(
            process,
            check=True,
            stderr=subprocess.PIPE,
            universal_newlines=True,
            shell=is_win_or_bat(),
        )

        if result.returncode == 0:
            print("Maven build succeeded")
        else:
            print("Maven clean failed. Error output:")
            print(result.stderr)
    except subprocess.CalledProcessError as e:
        print(f"Error running 'mvn clean': {e}")
        sys.exit(-1)

    return result


def copy_jars(graal_jars_src_dir, graal_jars_dst_dir):
    """
    Copies GraalVM jars to the TornadoVM distribution directory.

    Args:
        graal_jars_src_dir (str): Path to the directory containing GraalVM jars.
        graal_jars_dst_dir (str): Path to the directory to copy the GraalVM jars to.
    """
    files_to_copy = os.listdir(graal_jars_src_dir)

    for file_name in files_to_copy:
        source_file = os.path.join(graal_jars_src_dir, file_name)
        destination_file = os.path.join(graal_jars_dst_dir, file_name)
        if os.path.isfile(source_file):
            shutil.copy(source_file, destination_file)

def generate_setvars_files():
    """
    Generate setvars.cmd (Windows) or setvars.sh (Unix/Linux/Mac) file with the correct TORNADO_SDK path.

    This function creates an environment setup script at the project root that:
    - Set TORNADO_SDK to the correct SDK location
    - Add the SDK bin directory to PATH
    - Preserve the current JAVA_HOME setting
    """
    project_root = os.getcwd()
    tornado_sdk = os.environ.get('TORNADO_SDK')
    java_home = os.environ.get('JAVA_HOME', '')

    if not tornado_sdk:
        print("Warning: TORNADO_SDK not set, skipping setvars file generation")
        return

    if os.name == 'nt':
        # Generate setvars.cmd for Windows
        setvars_cmd_path = os.path.join(project_root, "setvars.cmd")
        setvars_cmd_content = f"""@echo off
REM TornadoVM Environment Setup Script (Windows)
REM Generated automatically by the build process

set JAVA_HOME={java_home}
set TORNADO_SDK={tornado_sdk}
set PATH=%TORNADO_SDK%\\bin;%PATH%
"""

        with open(setvars_cmd_path, 'w', newline='\r\n') as f:
            f.write(setvars_cmd_content)

        print(f"Generated utilities:")
        print(f"   [Windows-env]: {setvars_cmd_path}")
    else:
        # Generate setvars.sh for Unix/Linux/Mac
        setvars_sh_path = os.path.join(project_root, "setvars.sh")
        setvars_sh_content = f"""#!/bin/bash
# TornadoVM Environment Setup Script (Unix/Linux/Mac)
# Generated automatically by the build process

export JAVA_HOME="{java_home}"
export TORNADO_SDK="{tornado_sdk}"
export PATH="$TORNADO_SDK/bin:$PATH"
"""

        with open(setvars_sh_path, 'w', newline='\n') as f:
            f.write(setvars_sh_content)

        # Make setvars.sh executable on Unix systems
        os.chmod(setvars_sh_path, 0o755)

        print(f"Generated utilities:")
        print(f"   [Unix-env]: {setvars_sh_path}")


def post_installation_actions(backend_profiles, mvn_build_result, args, graal_jars_status):
    """
    Performs post-installation actions.

    Args:
        backend_profiles (str): The processed backend options.
        mvn_build_result (CompletedProcess): Result of the Maven build process.
        args (object): The user-defined arguments.
        backend (str): The backend string for argfile generation.
    """
    if mvn_build_result.returncode == 0:
        # Update all PATHs - this must run first to set TORNADO_SDK
        updp.update_tornado_paths()

        # Generate setvars files with the correct SDK path
        generate_setvars_files()

        # Create tornado.backend file in the extracted SDK
        # Maven filtering should handle this, but as a fallback (especially on Windows), ensure it exists
        backend_file_path = os.path.join(f"{os.environ['TORNADO_SDK']}", "etc", "tornado.backend")
        os.makedirs(os.path.dirname(backend_file_path), exist_ok=True)
        with open(backend_file_path, "w") as backend_file:
            backend_file.write(f"tornado.backends={backend_profiles}\n")

        # Note: Graal JARs are now included by Maven assembly from graalJars/ directory
        # See tornado-assembly/assembly.xml for the fileSet configuration

        # Generate argfile template and final argfile
        # This creates two files in the TORNADO_SDK directory (dist/):
        # 1. tornado-argfile.template - Contains ${TORNADO_SDK} placeholders for portability
        # 2. tornado-argfile - Ready-to-use argfile with actual paths expanded
        # Both files use OS-appropriate path separators (/ on Unix, \ on Windows)
        generate_argfile_template(args.backend)
        if not args.sdk:
            expand_argfile_template()

        # On Windows, create executables before packaging
        if os.name == 'nt':
            cutils.runPyInstaller(os.getcwd(), os.environ['TORNADO_SDK'])

        # Create SDK archives last, after all files (including argfile and Windows executables) are ready
        if args.sdk:
            package_sdk_archives()

    else:
        print("\nCompilation failed\n")
        sys.exit(-1)


def parse_args():
    """
    Parse command line arguments
    """
    parser = argparse.ArgumentParser(description="Tool to compile TornadoVM")
    parser.add_argument(
        "--jdk", help="JDK version (e.g., jdk21, graal-jdk-21)"
    )
    parser.add_argument("--backend", help="e.g., opencl,ptx,spirv")
    parser.add_argument(
        "--polyglot",
        action="store_true",
        dest="polyglot",
        default=False,
        help="To enable interoperability with Truffle Programming Languages."
    )
    parser.add_argument(
        "--mvn_single_threaded",
        action="store_true",
        dest="mavenSingleThreaded",
        default=False,
        help="To build with maven while using one thread."
    )
    parser.add_argument(
        "--rebuild",
        action="store_true",
        dest="rebuild",
        default=False,
        help="Enable pull and rebuild of the external dependencies."
    )
    parser.add_argument(
        "--sdk",
        action="store_true",
        dest="sdk",
        default=False,
        help="Generate SDK for current platform. JDK is auto-detected from JAVA_HOME."
    )

    args = parser.parse_args()
    return args


def generate_argfile_template(backend):
        """
        Generate the argfile template for your current build.
        The template contains ${TORNADO_SDK} placeholders that will be expanded at runtime.

        Note: SPIRV backend depends on OpenCL runtime, so when building with SPIRV,
        we automatically include OpenCL exports in the argfile.
        """
        # If SPIRV is in the backend list, ensure OpenCL is also included for exports
        # SPIRV can run on the OpenCL runtime, so OpenCL module must be available
        backend_list = [b.strip() for b in backend.split(",")]
        if "spirv" in backend_list and "opencl" not in backend_list:
            backend_list.insert(0, "opencl")  # Add OpenCL before SPIRV
            backend = ",".join(backend_list)

        scripts_dir = os.path.join(f"{os.environ['TORNADO_SDK']}", "bin")
        current = os.getcwd()
        os.chdir(scripts_dir)

        # Use 'python' on Windows, 'python3' on Unix-like systems
        python_cmd = "python" if os.name == 'nt' else "python3"
        gen_script = os.path.join(scripts_dir, "gen-tornado-argfile-template.py")

        try:
            if is_win_or_bat():
                # On Windows with shell=True, pass as a single string
                result = subprocess.run(
                    f'{python_cmd} "{gen_script}" {backend}',
                    shell=True,
                    check=True,
                    capture_output=True,
                    text=True
                )
            else:
                # On Unix-like systems, pass as a list without shell
                result = subprocess.run(
                    [python_cmd, gen_script, backend],
                    check=True,
                    capture_output=True,
                    text=True
                )

            # Print output for debugging
            if result.stdout:
                print(result.stdout)
            if result.stderr:
                print(result.stderr, file=sys.stderr)

        except subprocess.CalledProcessError as e:
            print(f"\n[ERROR] Failed to generate tornado-argfile")
            print(f"[ERROR] Command: {e.cmd}")
            print(f"[ERROR] Return code: {e.returncode}")
            if e.stdout:
                print(f"[ERROR] stdout: {e.stdout}")
            if e.stderr:
                print(f"[ERROR] stderr: {e.stderr}")
            sys.exit(-1)
        finally:
            os.chdir(current)


def expand_argfile_template():
    """
    Expand the tornado-argfile.template by replacing ${TORNADO_SDK} placeholders
    with the actual TORNADO_SDK path and generate the final tornado-argfile.

    This function creates a ready-to-use tornado-argfile in the TORNADO_SDK directory
    that can be used with @argfile syntax. The expansion is done in pure Python for
    cross-platform portability (Linux, macOS, Windows).
    """
    tornado_sdk = os.environ.get("TORNADO_SDK")
    if not tornado_sdk:
        print("[WARNING] TORNADO_SDK not set, skipping argfile expansion")
        return

    template_path = os.path.join(tornado_sdk, "tornado-argfile.template")
    output_path = os.path.join(tornado_sdk, "tornado-argfile")

    if not os.path.exists(template_path):
        print(f"[WARNING] Template file not found: {template_path}")
        return

    try:
        # Read the template file
        with open(template_path, "r") as template_file:
            template_content = template_file.read()

        # Expand ${TORNADO_SDK} placeholder with the actual path
        # This works across all platforms (Linux, macOS, Windows)
        expanded_content = template_content.replace("${TORNADO_SDK}", tornado_sdk)

        # Write the expanded argfile
        with open(output_path, "w") as output_file:
            output_file.write(expanded_content)

        print(f"   [argfile]: {output_path}")

    except Exception as e:
        print(f"[ERROR] Failed to expand argfile template: {e}")
        sys.exit(-1)


def package_sdk_archives():
    """
    Create zip and tar.gz archives of the SDK directory after all files are ready.
    This runs after argfile generation to ensure it's included in the distribution.

    The archives are created in the main dist/ directory with the structure:
    - tornadovm-VERSION-BACKEND-PLATFORM-ARCH.tar.gz
    - tornadovm-VERSION-BACKEND-PLATFORM-ARCH.zip

    Each archive contains:
    - tornadovm-VERSION-BACKEND/ (the SDK directory)
    """
    import tarfile
    import zipfile
    from pathlib import Path

    # --- Simple ANSI color helpers (safe if terminal supports them) ---
    RESET = "\033[0m"
    BOLD = "\033[1m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    CYAN = "\033[96m"

    def ok(msg: str) -> None:
        print(f"  {GREEN}[OK]{RESET} {msg}")

    def warn(msg: str) -> None:
        print(f"  {YELLOW}[WARNING]{RESET} {msg}")

    tornado_sdk = os.environ.get('TORNADO_SDK')
    if not tornado_sdk:
        warn("TORNADO_SDK not set; skipping archive creation.")
        return

    # Get the SDK directory paths
    # TORNADO_SDK = dist/tornadovm-X.Y.Z-BACKEND-PLATFORM-ARCH/tornadovm-X.Y.Z-BACKEND/
    sdk_path = Path(tornado_sdk)
    sdk_name = sdk_path.name  # e.g., tornadovm-1.1.2-dev-opencl
    outer_dir = sdk_path.parent  # e.g., dist/tornadovm-1.1.2-dev-opencl-mac-aarch64
    outer_dir_name = outer_dir.name  # e.g., tornadovm-1.1.2-dev-opencl-mac-aarch64
    dist_dir = outer_dir.parent  # e.g., dist/

    # Header
    print()
    print("=" * 72)
    print(f"{BOLD}SDK Distribution Packaging{RESET}".center(72))
    print("=" * 72)

    # Context block
    print(f"{CYAN}Environment{RESET}")
    print(f"  SDK directory       : {sdk_path}")
    print(f"  Archive base name   : {outer_dir_name}")
    print(f"  Distribution folder : {dist_dir}")
    print()

    # Verify argfile exists
    argfile_path = sdk_path / "tornado-argfile"
    if argfile_path.exists():
        ok(f"tornado-argfile found and will be included ({argfile_path})")
    else:
        warn(f"To generate the tornado-argfile, run: tornado --generate-argfile")
    print()

    # Change to the dist directory to create archives with correct structure
    original_dir = os.getcwd()
    os.chdir(dist_dir)

    try:
        # Use outer_dir_name for the archive names (includes platform-arch)
        # but archive the inner sdk_name directory
        print(f"{CYAN}Creating archives...{RESET}")

        # TAR.GZ
        tar_filename = f"{outer_dir_name}.tar.gz"
        with tarfile.open(tar_filename, "w:gz") as tar:
            # Add from outer_dir/sdk_name, archive as sdk_name/
            tar.add(os.path.join(outer_dir_name, sdk_name), arcname=sdk_name)
        ok(f"Created {tar_filename}")

        # ZIP
        zip_filename = f"{outer_dir_name}.zip"
        with zipfile.ZipFile(zip_filename, 'w', zipfile.ZIP_DEFLATED) as zipf:
            sdk_dir_to_archive = os.path.join(outer_dir_name, sdk_name)
            for root, dirs, files in os.walk(sdk_dir_to_archive):
                for file in files:
                    file_path = os.path.join(root, file)
                    # Calculate relative path from outer_dir_name/sdk_name to archive as sdk_name/
                    rel_path = os.path.relpath(file_path, outer_dir_name)
                    zipf.write(file_path, rel_path)
        ok(f"Created {zip_filename}")

        # Footer
        print()
        print("=" * 72)
        ok("SDK packaging complete!")
        print(f"  Archives created in: {dist_dir}")
        print("=" * 72)

    finally:
        os.chdir(original_dir)


def main():
    args = parse_args()

    graal_jars_status = should_handle_graal_jars(args.jdk)

    maven_cleanup()

    pull_graal_jars_if_needed(graal_jars_status)

    backend_profiles = process_backends_as_mvn_profiles(args.backend)

    if "opencl" in args.backend:
        clone_opencl_headers()

    if "spirv" in args.backend:
        # 1) Build the SPIR-V Toolkit
        build_spirv_toolkit_and_level_zero(args.rebuild)

        # 2) Build the Level Zero JNI library
        build_levelzero_jni_lib(args.rebuild)

    mvn_build_result = build_tornadovm(args, backend_profiles)

    post_installation_actions(
        backend_profiles, mvn_build_result, args, graal_jars_status
    )



if __name__ == "__main__":
    main()
